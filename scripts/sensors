#! /usr/bin/env ruby

require 'rock/bundles'
require 'orocos/async'

Bundles.initialize

def connect_device_to_bus(bus, task)
    task_name = task.basename
    task.io_port = ""
    bus.port(task_name).connect_to task.io_raw_in, :type => :buffer, :size => 50
    task.io_raw_out.connect_to bus.port("w#{task_name}"), :type => :buffer, :size => 50
end

def restart_on_exception(task)
    task.to_async.on_state_change do |state|
        if !task.runtime_state?(state)
            begin
                if task.exception_state?(state)
                    task.reset_exception
                    task.configure
                    task.start
                elsif task.rtt_state == :PRE_OPERATIONAL
                    task.configure
                    task.start
                elsif task.rtt_state == :STOPPED
                    task.start
                end
            rescue Orocos::StateTransitionFailed
            end
        end
    end
end

config = 'blue'
options = OptionParser.new do |opt|
    opt.on '--green', 'run with the green board (default is to run for the blue board)' do |flag|
	if flag
	    config = 'green'
	end
    end
end
options.parse ARGV

Bundles.run \
    'busses',
    'inclinometer::Task' => ['inclination_right', 'inclination_body', 'inclination_key'],
    'pressure_velki::Task' => 'pressure',
    'ptu_kongsberg_oe10::Task' => 'ptu',
    'sonar_tritech::Micron' => 'micron',
    'sonar_tritech::Profiling' => 'seaking' do

    bus1   = Bundles.get 'bus1'
    Orocos.conf.apply bus1, ['default', "#{config}1"]
    bus2   = Bundles.get 'bus2'
    Orocos.conf.apply bus2, ['default', "#{config}2"]

# Configure the bus driver first, we need it to connect the micron
    bus1.configure
    bus2.configure
    Orocos.log_all

    bus1.start
    bus2.start

    inclination_right_bus =
	if config == 'green' then bus1
	else bus2
	end
    inclination_right  = Bundles.get 'inclination_right'
    inclination_right_bus.inclination_right.connect_to inclination_right.analog_input
    inclination_right.direction_flag = true
    inclination_right.configure
    inclination_right.start

    inclination_key   = Bundles.get 'inclination_key'
    bus2.inclination_key.
	connect_to inclination_key.analog_input
    inclination_key.direction_flag = false
    inclination_key.configure
    inclination_key.start

    inclination_body = Bundles.get 'inclination_body'
    bus1.inclination_body.
	connect_to inclination_body.analog_input
    inclination_body.direction_flag = true
    inclination_body.configure
    inclination_body.start

    pressure = Bundles.get 'pressure'
    restart_on_exception(pressure)
    connect_device_to_bus(bus1, pressure)
    pressure.configure
    pressure.start

    ptu = Bundles.get 'ptu'
    restart_on_exception(ptu)
    connect_device_to_bus(bus2, ptu)
    ptu.configure
    ptu.start



    micron = Bundles.get 'micron'
    seaking = Bundles.get 'seaking'

    if bus2.has_port?('micron')
	restart_on_exception(micron)
        connect_device_to_bus(bus2, micron)
        #micron.configure
        #micron.start
    else
	restart_on_exception(seaking)
        connect_device_to_bus(bus2, seaking)
        #seaking.configure
        #seaking.start
    end

    Bundles.watch(
        bus1, bus2,
        inclination_right, inclination_body, inclination_key,
        pressure, micron, seaking, ptu
    ) do
	# Workaround bug in orocos.rb to get the on_state_change in restart_on_exception working
	Orocos::Async.event_loop.step
    end
end

