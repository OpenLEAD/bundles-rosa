#! /usr/bin/env ruby
#
require 'rock/bundle'
require 'vizkit'

config = 'green'
options = OptionParser.new do |opt|
    opt.on '--blue', 'run with the blue board (default is to run for the green board)' do |flag|
	if flag
	    config = 'blue'
	end
    end
end
options.parse ARGV


Bundles.initialize
Orocos.load_typekit 'base'
Orocos.load_typekit 'raw_io'

main_ui   = Vizkit.default_loader.load Bundles.find_file('scripts', 'cmd_status.ui')
main_ui.window_title = "ROSA - Control and Status Debugging UI"
task_states = Vizkit.default_loader.StateViewer
status_ui = Vizkit.default_loader.load Bundles.find_file('scripts', 'gui.ui')
status_layout = Qt::VBoxLayout.new(main_ui.statusGroup)
status_layout.add_widget task_states
status_layout.add_widget status_ui
# Connect the slide and the spin
status_ui.pressureSlide.connect(SIGNAL('valueChanged(int)')) do |value|
    status_ui.pressureSpin.value = Float(value) / 10
end
status_ui.pressureSpin.connect(SIGNAL('valueChanged(double)')) do |value|
    status_ui.pressureSlide.value = Integer(value * 10)
end
main_ui.resize(900, 0)
main_ui.show

if config == 'blue'
    status_ui.connect_to_task 'bus2' do |task|
        task_states.add task
        inductiveKeyAttachedButton.connect PORT('inductive_key_attached'), SLOT('setChecked(bool)'),
            getter: lambda { |sample| sample.data != 0 }
    end
    status_ui.connect_to_task 'bus1' do |task|
        task_states.add task
        inductiveLeftButton.connect PORT('inductive_left'), SLOT('setChecked(bool)'),
            getter: lambda { |sample| sample.data != 0 }
        inductiveRightButton.connect PORT('inductive_right'), SLOT('setChecked(bool)'),
            getter: lambda { |sample| sample.data != 0 }
    end
else
    status_ui.connect_to_task 'bus1' do |task|
        task_states.add task
        inductiveLeftButton.connect PORT('inductive_left'), SLOT('setChecked(bool)'),
            getter: lambda { |sample| sample.data != 0 }
        inductiveRightButton.connect PORT('inductive_right'), SLOT('setChecked(bool)'),
            getter: lambda { |sample| sample.data != 0 }
        inductiveKeyAttachedButton.connect PORT('inductive_key_attached'), SLOT('setChecked(bool)'),
            getter: lambda { |sample| sample.data != 0 }
    end
    status_ui.connect_to_task 'bus2' do |task|
        task_states.add task
    end
end

status_ui.connect_to_task 'micron' do |task|
    task_states.add task
end

status_ui.connect_to_task 'seaking' do |task|
    task_states.add task
end

status_ui.connect_to_task 'inclination_body' do |task|
    task_states.add task
    inclinationBodySlide.connect PORT('angle'), SLOT('setValue(int)'),
        getter: lambda { |sample| Integer(sample.rad * 180 / Math::PI) }
end
status_ui.connect_to_task 'pressure' do |task|
    task_states.add task
    pressureSlide.connect PORT('pressure_samples'), SLOT('setValue(int)'),
        getter: lambda { |sample| Integer(sample.pascal / 10_000) }
end
status_ui.connect_to_task 'ptu' do |task|
    task_states.add task
    panSlide.connect PORT('joints_samples'), SLOT('setValue(int)'),
        getter: lambda { |sample| Integer(sample.elements[0].position * 180 / Math::PI) }
    tiltSlide.connect PORT('joints_samples'), SLOT('setValue(int)'),
        getter: lambda { |sample| Integer(sample.elements[1].position * 180 / Math::PI) }
    task.on_state_change do |state|
        if state == :RUNNING
            listener = task.port('joints_samples').on_data do |sample|
        	main_ui.panSetSlide.value = sample.elements[0].position * 180 / Math::PI
        	main_ui.tiltSetSlide.value = sample.elements[1].position * 180 / Math::PI
        	main_ui.panSetSlide.enabled = true
        	main_ui.tiltSetSlide.enabled = true
        	listener.stop
            end
            initialize_command_from_next_joint_sample = true
        else
            main_ui.panSetSlide.enabled = true
            main_ui.tiltSetSlide.enabled = true
        end
    end
end

ptu_cmd = Types::Base::Commands::Joints.new(
    time: Time.now,
    names: %w{pan tilt},
    elements: [ Hash[position: 0], Hash[position: 0] ])
main_ui.connect_to_task 'ptu' do |_|
    main_ui.panSetSlide.enabled = false
    panSetSlide.connect SIGNAL('valueChanged(int)'), PORT('joints_cmd'),
        getter: lambda { |value| ptu_cmd.elements[0].position = value * Math::PI / 180; ptu_cmd }
    main_ui.tiltSetSlide.enabled = false
    tiltSetSlide.connect SIGNAL('valueChanged(int)'), PORT('joints_cmd'),
        getter: lambda { |value| ptu_cmd.elements[1].position = value * Math::PI / 180; pp ptu_cmd; ptu_cmd }
end

runTimer = Qt::Timer.new
scanTimer = Qt::Timer.new

runTimer.connect SIGNAL('timeout()'), main_ui.panSetSlide, SLOT('setValue(int)')
    getter: lambda { |value| (main_ui.panSetSlide.value + main_ui.increment.value) }

runTimer.connect SIGNAL('timeout()') do
    if (main_ui.panSetSlide.value - status_ui.panSlide.value).abs <= 3
        if main_ui.panSetSlide.value > main_ui.endAngle.value
            main_ui.runButton.setChecked(false))
            stop
        else
            scanTimer.start
        end
end

runButton.connect SIGNAL('toggled(bool)') do |flag|
    if flag
        runTimer.start(100)
        scanTimer.setInterval(main_ui.periodSample.value * #NEED CONVERSION)
        scanTimer.setSingleShot(true)
    else
        runTimer.stop
    end
end
        getter: lambda {Thread.new{ main_ui.startAngle.value.step(main_ui.endAngle.value, main_ui.increment.value) do |angle|
           ptu_cmd.elements[0].position =  angle * Math::PI / 180
           puts "#{angle}"
           ptu_cmd
           sleep Integer(main_ui.periodSample.value)
        end} }
end

Vizkit.exec
